<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite-like 3D Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .joystick {
            position: absolute;
            bottom: 20%;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            touch-action: none;
        }
        #joystick-left { left: 5%; }
        #joystick-right { right: 5%; }
        .joystick-thumb {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .action-buttons {
            position: absolute;
            bottom: 30%;
            right: 5%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        button {
            margin: 10px 0;
            padding: 15px;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            touch-action: manipulation;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="joystick" id="joystick-left">
        <div class="joystick-thumb" id="thumb-left"></div>
    </div>
    <div class="joystick" id="joystick-right">
        <div class="joystick-thumb" id="thumb-right"></div>
    </div>
    <div class="action-buttons">
        <button id="jump">‚¨ÜÔ∏è</button>
        <button id="shoot">üî´</button>
        <button id="sprint">üèÉ</button>
        <button id="wall">üß±</button>
        <button id="floor">üìê</button>
        <button id="ramp">‚ÜóÔ∏è</button>
        <button id="slide">‚ÜòÔ∏è</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Game state
        const gameState = {
            scene: null,
            camera: null,
            renderer: null,
            player: null,
            gun: null,
            clock: new THREE.Clock(),
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            projectiles: [],
            yaw: 0,
            pitch: 0,
            moveSpeed: 5,
            isSprinting: false,
            isJumping: false,
            isSliding: false,
            slideTimer: 0,
            leftTouchId: null,
            rightTouchId: null,
            leftStart: new THREE.Vector2(),
            rightStart: new THREE.Vector2(),
            leftThumb: document.getElementById('thumb-left'),
            rightThumb: document.getElementById('thumb-right'),
            buildMaterial: new THREE.MeshStandardMaterial({ color: 0x808080 }),
            buildings: [],
            keys: {}
        };

        // Scene setup
        function setupScene() {
            gameState.scene = new THREE.Scene();
            gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            gameState.renderer = new THREE.WebGLRenderer();
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(gameState.renderer.domElement);

            // Lights
            gameState.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            gameState.scene.add(directionalLight);

            // Ground
            const textureLoader = new THREE.TextureLoader();
            const grassDiffuse = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            grassDiffuse.repeat.set(50, 50);
            grassDiffuse.wrapS = grassDiffuse.wrapT = THREE.RepeatWrapping;
            const groundMaterial = new THREE.MeshStandardMaterial({ map: grassDiffuse, roughness: 0.8 });
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            gameState.scene.add(ground);
        }

        // Create player with custom geometry
        function createPlayer() {
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

            // Body (cylinder)
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.2;

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 16);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(0.5, 0.8, 0);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.7, 16);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.25, 0.2, 0);
            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.25, 0.2, 0);

            // Group as player
            gameState.player = new THREE.Group();
            gameState.player.add(body, head, leftArm, rightArm, leftLeg, rightLeg);
            gameState.player.position.y = 1;
            gameState.scene.add(gameState.player);

            // Gun
            const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
            gameState.gun = new THREE.Mesh(gunGeometry, bodyMaterial);
            gameState.gun.position.set(0.5, 1, -0.5);
            gameState.gun.rotation.y = Math.PI / 2;
            gameState.player.add(gameState.gun);
        }

        // Create buildings
        function createBuildings() {
            const loader = new THREE.GLTFLoader();
            for (let i = 0; i < 5; i++) {
                const houseGeometry = new THREE.BoxGeometry(10, 10, 10);
                const houseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                house.position.set(Math.random() * 200 - 100, 5, Math.random() * 200 - 100);
                gameState.scene.add(house);
                gameState.buildings.push(house);
            }

            loader.load(
                'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/Lantern/glTF/Lantern.gltf',
                (gltf) => {
                    gameState.buildings.forEach((house) => gameState.scene.remove(house));
                    gameState.buildings = [];
                    const houseTemplate = gltf.scene;
                    houseTemplate.scale.set(5, 5, 5);
                    for (let i = 0; i < 5; i++) {
                        const house = houseTemplate.clone();
                        house.position.set(Math.random() * 200 - 100, 0, Math.random() * 200 - 100);
                        gameState.scene.add(house);
                        gameState.buildings.push(house);
                    }
                },
                undefined,
                (err) => console.error('Failed to load house model:', err)
            );
        }

        // Setup controls
        function setupControls() {
            const joystickLeft = document.getElementById('joystick-left');
            const joystickRight = document.getElementById('joystick-right');

            joystickLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                gameState.leftStart.set(touch.clientX, touch.clientY);
                gameState.leftTouchId = touch.identifier;
                updateThumb(gameState.leftThumb, 75, 75);
            });

            joystickRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                gameState.rightStart.set(touch.clientX, touch.clientY);
                gameState.rightTouchId = touch.identifier;
                updateThumb(gameState.rightThumb, 75, 75);
            });

            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.touches) {
                    if (touch.identifier === gameState.leftTouchId) {
                        let dx = touch.clientX - gameState.leftStart.x;
                        let dy = touch.clientY - gameState.leftStart.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 75) {
                            dx = dx * 75 / dist;
                            dy = dy * 75 / dist;
                        }
                        gameState.direction.x = dx / 75;
                        gameState.direction.z = dy / 75;
                        updateThumb(gameState.leftThumb, 75 + dx, 75 + dy);
                    }
                    if (touch.identifier === gameState.rightTouchId) {
                        let dx = touch.clientX - gameState.rightStart.x;
                        let dy = touch.clientY - gameState.rightStart.y;
                        gameState.yaw -= dx * 0.005;
                        gameState.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameState.pitch - dy * 0.005));
                        gameState.rightStart.set(touch.clientX, touch.clientY);
                    }
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === gameState.leftTouchId) {
                        gameState.direction.set(0, 0, 0);
                        gameState.leftTouchId = null;
                        updateThumb(gameState.leftThumb, 75, 75);
                    }
                    if (touch.identifier === gameState.rightTouchId) {
                        gameState.rightTouchId = null;
                        updateThumb(gameState.rightThumb, 75, 75);
                    }
                }
            });

            // Action buttons
            document.getElementById('jump').addEventListener('touchstart', () => gameState.isJumping = true);
            document.getElementById('shoot').addEventListener('touchstart', shoot);
            document.getElementById('sprint').addEventListener('touchstart', () => gameState.isSprinting = true);
            document.getElementById('sprint').addEventListener('touchend', () => gameState.isSprinting = false);
            document.getElementById('wall').addEventListener('touchstart', () => build('wall'));
            document.getElementById('floor').addEventListener('touchstart', () => build('floor'));
            document.getElementById('ramp').addEventListener('touchstart', () => build('ramp'));
            document.getElementById('slide').addEventListener('touchstart', slide);

            // Keyboard controls
            document.addEventListener('keydown', (e) => gameState.keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => gameState.keys[e.key.toLowerCase()] = false);

            // Mouse controls
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === gameState.renderer.domElement) {
                    gameState.yaw -= e.movementX * 0.002;
                    gameState.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameState.pitch - e.movementY * 0.002));
                }
            });
            gameState.renderer.domElement.addEventListener('click', () => gameState.renderer.domElement.requestPointerLock());

            // Window resize
            window.addEventListener('resize', () => {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateThumb(thumb, x, y) {
            thumb.style.left = `${x}px`;
            thumb.style.top = `${y}px`;
        }

        function updateMovement(delta) {
            if (!gameState.player) return;
            const currentSpeed = gameState.isSliding ? 15 : (gameState.isSprinting ? 8 : gameState.moveSpeed);
            gameState.velocity.x = 0;
            gameState.velocity.z = 0;

            // Joystick
            if (gameState.direction.lengthSq() > 0) {
                const moveDir = gameState.direction.clone().normalize().multiplyScalar(currentSpeed);
                moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.yaw);
                gameState.velocity.x += moveDir.x;
                gameState.velocity.z += moveDir.z;
            }

            // Keyboard
            const keyDir = new THREE.Vector3();
            if (gameState.keys['w'] || gameState.keys['arrowup']) keyDir.z -= 1;
            if (gameState.keys['s'] || gameState.keys['arrowdown']) keyDir.z += 1;
            if (gameState.keys['a'] || gameState.keys['arrowleft']) keyDir.x -= 1;
            if (gameState.keys['d'] || gameState.keys['arrowright']) keyDir.x += 1;
            if (gameState.keys[' '] && !gameState.isJumping) gameState.isJumping = true;
            if (gameState.keys['shift']) gameState.isSprinting = true;
            if (gameState.keys['f']) shoot();
            if (gameState.keys['1']) build('wall');
            if (gameState.keys['2']) build('floor');
            if (gameState.keys['3']) build('ramp');
            if (gameState.keys['c']) slide();
            if (keyDir.lengthSq() > 0) {
                keyDir.normalize().multiplyScalar(currentSpeed);
                keyDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.yaw);
                gameState.velocity.x += keyDir.x;
                gameState.velocity.z += keyDir.z;
            }

            // Gamepad
            const gamepads = navigator.getGamepads();
            if (gamepads[0]) {
                const gp = gamepads[0];
                const gpDir = new THREE.Vector3(gp.axes[0], 0, gp.axes[1]).normalize().multiplyScalar(currentSpeed);
                gpDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.yaw);
                gameState.velocity.x += gpDir.x;
                gameState.velocity.z += gpDir.z;
                gameState.yaw -= gp.axes[2] * 0.05;
                gameState.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameState.pitch - gp.axes[3] * 0.05));
                if (gp.buttons[0].pressed) gameState.isJumping = true;
                if (gp.buttons[2].pressed) shoot();
                if (gp.buttons[1].pressed) slide();
                if (gp.buttons[5].pressed) gameState.isSprinting = true;
            }

            gameState.player.position.x += gameState.velocity.x * delta;
            gameState.player.position.z += gameState.velocity.z * delta;
            gameState.player.rotation.y = gameState.yaw;
        }

        function updatePhysics(delta) {
            if (!gameState.player) return;
            gameState.velocity.y -= 9.81 * delta * 2;
            gameState.player.position.y += gameState.velocity.y * delta;

            if (gameState.player.position.y <= 0) {
                gameState.player.position.y = 0;
                gameState.velocity.y = 0;
                if (gameState.isJumping) {
                    gameState.velocity.y = 10;
                    gameState.isJumping = false;
                }
            }
        }

        function updateCamera() {
            if (!gameState.player) return;
            const offset = new THREE.Vector3(0, 3, 8).applyEuler(new THREE.Euler(gameState.pitch, gameState.yaw, 0, 'XYZ'));
            gameState.camera.position.copy(gameState.player.position).add(offset);
            gameState.camera.lookAt(gameState.player.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
        }

        function updateProjectiles(delta) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                proj.position.add(proj.velocity.clone().multiplyScalar(delta));
                if (proj.position.length() > 500) {
                    gameState.scene.remove(proj);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        function shoot() {
            if (!gameState.player) return;
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(geometry, material);
            const bulletPos = new THREE.Vector3();
            if (gameState.gun) gameState.gun.getWorldPosition(bulletPos);
            else bulletPos.copy(gameState.player.position).add(new THREE.Vector3(0, 1, 0));
            bullet.position.copy(bulletPos);
            const shootDir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(gameState.pitch, gameState.yaw, 0, 'XYZ'));
            bullet.velocity = shootDir.multiplyScalar(100);
            gameState.scene.add(bullet);
            gameState.projectiles.push(bullet);
        }

        function build(type) {
            if (!gameState.player) return;
            let geometry;
            if (type === 'wall') geometry = new THREE.PlaneGeometry(4, 4);
            else if (type === 'floor') geometry = new THREE.PlaneGeometry(4, 4);
            else if (type === 'ramp') geometry = new THREE.PlaneGeometry(4, 4 * Math.sqrt(2));
            const mesh = new THREE.Mesh(geometry, gameState.buildMaterial);
            const offset = new THREE.Vector3(0, 0, -5).applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.yaw);
            mesh.position.copy(gameState.player.position).add(offset);
            if (type === 'wall') {
                mesh.position.y = 2;
                mesh.rotation.y = gameState.yaw;
            } else if (type === 'floor') {
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = gameState.player.position.y;
            } else if (type === 'ramp') {
                mesh.position.y = 2;
                mesh.rotation.set(-Math.PI / 4, gameState.yaw, 0);
            }
            gameState.scene.add(mesh);
        }

        function slide() {
            if (!gameState.player || gameState.isSliding) return;
            gameState.isSliding = true;
            gameState.slideTimer = 1;
            gameState.player.scale.y = 0.5;
            gameState.player.position.y = 0.5;
        }

        function updateSlide(delta) {
            if (!gameState.isSliding) return;
            gameState.slideTimer -= delta;
            if (gameState.slideTimer <= 0) {
                gameState.isSliding = false;
                if (gameState.player) {
                    gameState.player.scale.y = 1;
                    gameState.player.position.y = 1;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = gameState.clock.getDelta();

            updateMovement(delta);
            updatePhysics(delta);
            updateSlide(delta);
            updateCamera();
            updateProjectiles(delta);
            gameState.renderer.render(gameState.scene, gameState.camera);
        }

        // Initialize game
        setupScene();
        createPlayer();
        createBuildings();
        setupControls();
        animate();
    </script>
</body>
</html>
